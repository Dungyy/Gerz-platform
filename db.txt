-- =====================================================
-- GERZ SAAS DATABASE SCHEMA
-- Multi-tenant maintenance request platform
-- =====================================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =====================================================
-- 1. ORGANIZATIONS (Each property management company)
-- =====================================================
CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL, -- gerz.com/acme-properties
  logo_url TEXT,
  plan TEXT NOT NULL DEFAULT 'free', -- 'free', 'starter', 'professional', 'enterprise'
  stripe_customer_id TEXT,
  stripe_subscription_id TEXT,
  subscription_status TEXT DEFAULT 'trialing', -- 'trialing', 'active', 'past_due', 'canceled'
  trial_ends_at TIMESTAMPTZ,
  settings JSONB DEFAULT '{}', -- Custom settings per org
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 2. USERS (Profiles - extends auth.users)
-- =====================================================
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  full_name TEXT NOT NULL,
  email TEXT NOT NULL,
  role TEXT NOT NULL, -- 'owner', 'manager', 'maintenance', 'tenant'
  phone TEXT,
  avatar_url TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 3. PROPERTIES
-- =====================================================
CREATE TABLE properties (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  address TEXT NOT NULL,
  city TEXT,
  state TEXT,
  zip_code TEXT,
  country TEXT DEFAULT 'US',
  property_type TEXT, -- 'apartment', 'condo', 'house', 'commercial'
  manager_id UUID REFERENCES profiles(id),
  photo_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 4. UNITS
-- =====================================================
CREATE TABLE units (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  property_id UUID REFERENCES properties(id) ON DELETE CASCADE,
  unit_number TEXT NOT NULL,
  floor INTEGER,
  bedrooms INTEGER,
  bathrooms DECIMAL(3,1),
  square_feet INTEGER,
  tenant_id UUID REFERENCES profiles(id),
  lease_start_date DATE,
  lease_end_date DATE,
  monthly_rent DECIMAL(10,2),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(property_id, unit_number)
);

-- =====================================================
-- 5. MAINTENANCE REQUESTS
-- =====================================================
CREATE TABLE maintenance_requests (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  property_id UUID REFERENCES properties(id) ON DELETE CASCADE,
  unit_id UUID REFERENCES units(id) ON DELETE CASCADE,
  tenant_id UUID REFERENCES profiles(id),
  assigned_to UUID REFERENCES profiles(id),
  
  -- Request details
  title TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL, -- 'plumbing', 'electrical', 'hvac', 'appliance', 'structural', 'pest', 'other'
  priority TEXT NOT NULL DEFAULT 'medium', -- 'low', 'medium', 'high', 'emergency'
  status TEXT NOT NULL DEFAULT 'submitted', -- 'submitted', 'assigned', 'in_progress', 'completed', 'cancelled'
  
  -- Access and scheduling
  entry_allowed BOOLEAN DEFAULT FALSE,
  preferred_date DATE,
  preferred_time TEXT, -- 'morning', 'afternoon', 'evening', 'anytime'
  
  -- Media
  photo_urls TEXT[],
  
  -- Completion
  resolution_notes TEXT,
  completed_at TIMESTAMPTZ,
  completed_by UUID REFERENCES profiles(id),
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 6. REQUEST COMMENTS/UPDATES
-- =====================================================
CREATE TABLE request_comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  request_id UUID REFERENCES maintenance_requests(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id),
  comment TEXT NOT NULL,
  is_internal BOOLEAN DEFAULT FALSE, -- Only managers/staff see this
  photo_urls TEXT[],
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 7. MAINTENANCE STAFF
-- =====================================================
CREATE TABLE maintenance_staff (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  profile_id UUID REFERENCES profiles(id),
  specialties TEXT[], -- ['plumbing', 'electrical', 'hvac']
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 8. ACTIVITY LOG
-- =====================================================
CREATE TABLE activity_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  request_id UUID REFERENCES maintenance_requests(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id),
  action TEXT NOT NULL, -- 'created', 'updated', 'assigned', 'commented', 'completed'
  details JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================
CREATE INDEX idx_profiles_org ON profiles(organization_id);
CREATE INDEX idx_profiles_role ON profiles(role);
CREATE INDEX idx_properties_org ON properties(organization_id);
CREATE INDEX idx_units_property ON units(property_id);
CREATE INDEX idx_units_tenant ON units(tenant_id);
CREATE INDEX idx_requests_org ON maintenance_requests(organization_id);
CREATE INDEX idx_requests_property ON maintenance_requests(property_id);
CREATE INDEX idx_requests_status ON maintenance_requests(status);
CREATE INDEX idx_requests_tenant ON maintenance_requests(tenant_id);
CREATE INDEX idx_requests_assigned ON maintenance_requests(assigned_to);
CREATE INDEX idx_requests_created ON maintenance_requests(created_at);
CREATE INDEX idx_comments_request ON request_comments(request_id);
CREATE INDEX idx_activity_org ON activity_logs(organization_id);
CREATE INDEX idx_activity_request ON activity_logs(request_id);

-- =====================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE properties ENABLE ROW LEVEL SECURITY;
ALTER TABLE units ENABLE ROW LEVEL SECURITY;
ALTER TABLE maintenance_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE request_comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE maintenance_staff ENABLE ROW LEVEL SECURITY;
ALTER TABLE activity_logs ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- PROFILES POLICIES
-- =====================================================
CREATE POLICY "Users can view profiles in their org"
  ON profiles FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "Users can update their own profile"
  ON profiles FOR UPDATE
  USING (id = auth.uid());

-- =====================================================
-- ORGANIZATIONS POLICIES
-- =====================================================
CREATE POLICY "Users can view their own organization"
  ON organizations FOR SELECT
  USING (
    id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "Organization owners can update their org"
  ON organizations FOR UPDATE
  USING (
    id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role = 'owner'
    )
  );

-- =====================================================
-- PROPERTIES POLICIES
-- =====================================================
CREATE POLICY "Users can view properties in their org"
  ON properties FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "Managers and owners can create properties"
  ON properties FOR INSERT
  WITH CHECK (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role IN ('owner', 'manager')
    )
  );

CREATE POLICY "Managers and owners can update properties"
  ON properties FOR UPDATE
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role IN ('owner', 'manager')
    )
  );

-- =====================================================
-- UNITS POLICIES
-- =====================================================
CREATE POLICY "Users can view units in their org"
  ON units FOR SELECT
  USING (
    property_id IN (
      SELECT id FROM properties 
      WHERE organization_id IN (
        SELECT organization_id FROM profiles WHERE id = auth.uid()
      )
    )
  );

CREATE POLICY "Managers can manage units"
  ON units FOR ALL
  USING (
    property_id IN (
      SELECT id FROM properties 
      WHERE organization_id IN (
        SELECT organization_id FROM profiles 
        WHERE id = auth.uid() AND role IN ('owner', 'manager')
      )
    )
  );

-- =====================================================
-- MAINTENANCE REQUESTS POLICIES
-- =====================================================
CREATE POLICY "Tenants can view their own requests"
  ON maintenance_requests FOR SELECT
  USING (tenant_id = auth.uid());

CREATE POLICY "Staff can view all requests in their org"
  ON maintenance_requests FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role IN ('owner', 'manager', 'maintenance')
    )
  );

CREATE POLICY "Tenants can create requests"
  ON maintenance_requests FOR INSERT
  WITH CHECK (
    tenant_id = auth.uid() AND
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "Staff can update requests in their org"
  ON maintenance_requests FOR UPDATE
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role IN ('owner', 'manager', 'maintenance')
    )
  );

-- =====================================================
-- REQUEST COMMENTS POLICIES
-- =====================================================
CREATE POLICY "Users can view comments on requests they can see"
  ON request_comments FOR SELECT
  USING (
    -- Can see request
    request_id IN (
      SELECT id FROM maintenance_requests 
      WHERE tenant_id = auth.uid()
      OR organization_id IN (
        SELECT organization_id FROM profiles 
        WHERE id = auth.uid() AND role IN ('owner', 'manager', 'maintenance')
      )
    )
    AND
    -- If internal comment, must be staff
    (
      is_internal = FALSE
      OR
      auth.uid() IN (
        SELECT id FROM profiles 
        WHERE role IN ('owner', 'manager', 'maintenance')
      )
    )
  );

CREATE POLICY "Users can create comments on requests they can see"
  ON request_comments FOR INSERT
  WITH CHECK (
    user_id = auth.uid() AND
    request_id IN (
      SELECT id FROM maintenance_requests 
      WHERE tenant_id = auth.uid()
      OR organization_id IN (
        SELECT organization_id FROM profiles WHERE id = auth.uid()
      )
    )
  );

-- =====================================================
-- FUNCTIONS
-- =====================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_organizations_updated_at BEFORE UPDATE ON organizations
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_properties_updated_at BEFORE UPDATE ON properties
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_units_updated_at BEFORE UPDATE ON units
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_requests_updated_at BEFORE UPDATE ON maintenance_requests
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to log activity
CREATE OR REPLACE FUNCTION log_request_activity()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO activity_logs (organization_id, request_id, user_id, action, details)
  VALUES (
    NEW.organization_id,
    NEW.id,
    auth.uid(),
    TG_OP,
    jsonb_build_object(
      'status', NEW.status,
      'assigned_to', NEW.assigned_to
    )
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for activity logging
CREATE TRIGGER log_request_changes AFTER INSERT OR UPDATE ON maintenance_requests
  FOR EACH ROW EXECUTE FUNCTION log_request_activity();
```
&

-- Add SMS preferences to profiles table
ALTER TABLE profiles 
ADD COLUMN IF NOT EXISTS phone_verified BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS sms_notifications BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS sms_verification_code VARCHAR(6),
ADD COLUMN IF NOT EXISTS sms_verification_expires_at TIMESTAMPTZ;

-- Add SMS logs table for tracking
CREATE TABLE IF NOT EXISTS sms_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  recipient_phone VARCHAR(20) NOT NULL,
  recipient_user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  message_type VARCHAR(50) NOT NULL, -- 'invitation', 'request_update', 'verification', etc.
  message_body TEXT NOT NULL,
  status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'sent', 'delivered', 'failed'
  twilio_sid VARCHAR(100),
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  delivered_at TIMESTAMPTZ
);

-- Add indexes
CREATE INDEX IF NOT EXISTS idx_sms_logs_organization ON sms_logs(organization_id);
CREATE INDEX IF NOT EXISTS idx_sms_logs_recipient ON sms_logs(recipient_user_id);
CREATE INDEX IF NOT EXISTS idx_sms_logs_created ON sms_logs(created_at DESC);

-- Enable RLS
ALTER TABLE sms_logs ENABLE ROW LEVEL SECURITY;

-- RLS Policies for sms_logs
CREATE POLICY "Users can view SMS logs in their org"
  ON sms_logs FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "System can insert SMS logs"
  ON sms_logs FOR INSERT
  WITH CHECK (true);

-- Add notification preferences table
CREATE TABLE IF NOT EXISTS notification_preferences (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE UNIQUE,
  email_new_request BOOLEAN DEFAULT true,
  email_status_update BOOLEAN DEFAULT true,
  email_assignment BOOLEAN DEFAULT true,
  email_comment BOOLEAN DEFAULT true,
  sms_new_request BOOLEAN DEFAULT false,
  sms_status_update BOOLEAN DEFAULT true,
  sms_assignment BOOLEAN DEFAULT false,
  sms_emergency BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE notification_preferences ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own preferences"
  ON notification_preferences FOR SELECT
  USING (user_id = auth.uid());

CREATE POLICY "Users can update own preferences"
  ON notification_preferences FOR UPDATE
  USING (user_id = auth.uid());

CREATE POLICY "Users can insert own preferences"
  ON notification_preferences FOR INSERT
  WITH CHECK (user_id = auth.uid());

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_notification_preferences_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER notification_preferences_updated_at
  BEFORE UPDATE ON notification_preferences
  FOR EACH ROW
  EXECUTE FUNCTION update_notification_preferences_updated_at();


-- =========================================
-- CONTACT MESSAGES
-- =========================================
create table if not exists public.contact_messages (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  email text not null,
  subject text,
  message text not null,
  source text default 'web',
  status text not null default 'new' check (status in ('new','read','closed')),
  created_at timestamptz not null default now()
);

create index if not exists contact_messages_created_at_idx
  on public.contact_messages (created_at desc);

create index if not exists contact_messages_status_idx
  on public.contact_messages (status);

-- Optional: basic email format check (simple)
-- alter table public.contact_messages add constraint contact_messages_email_chk check (position('@' in email) > 1);


-- =========================================
-- FEATURE REQUESTS
-- =========================================
create table if not exists public.feature_requests (
  id uuid primary key default gen_random_uuid(),
  name text,
  email text,
  title text not null,
  details text not null,
  priority text not null default 'medium' check (priority in ('low','medium','high')),
  status text not null default 'new' check (status in ('new','reviewing','planned','shipped','closed')),
  created_at timestamptz not null default now()
);

create index if not exists feature_requests_created_at_idx
  on public.feature_requests (created_at desc);

create index if not exists feature_requests_status_idx
  on public.feature_requests (status);

create index if not exists feature_requests_priority_idx
  on public.feature_requests (priority);


-- request comments ---

-- Add organization_id column to request_comments table
ALTER TABLE request_comments 
ADD COLUMN IF NOT EXISTS organization_id UUID REFERENCES organizations(id);

-- Update existing comments with organization_id from the related request
UPDATE request_comments 
SET organization_id = (
  SELECT organization_id 
  FROM maintenance_requests 
  WHERE maintenance_requests.id = request_comments.request_id
)
WHERE organization_id IS NULL;

-- Make it NOT NULL after backfilling
ALTER TABLE request_comments 
ALTER COLUMN organization_id SET NOT NULL;

-- Add index for performance
CREATE INDEX IF NOT EXISTS idx_request_comments_organization_id 
ON request_comments(organization_id);

-- Verify the schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'request_comments';



-- Create invitations table
CREATE TABLE IF NOT EXISTS invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  invited_by UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('tenant', 'worker')),
  token TEXT NOT NULL UNIQUE,
  property_id UUID REFERENCES properties(id) ON DELETE SET NULL,
  unit_id UUID REFERENCES units(id) ON DELETE SET NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  accepted_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT valid_role CHECK (role IN ('tenant', 'worker'))
);

-- Index for faster lookups
CREATE INDEX idx_invitations_token ON invitations(token);
CREATE INDEX idx_invitations_email ON invitations(email);
CREATE INDEX idx_invitations_organization ON invitations(organization_id);

-- Enable RLS
ALTER TABLE invitations ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Managers can view their org invitations"
  ON invitations FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() 
      AND role IN ('owner', 'manager')
    )
  );

CREATE POLICY "Managers can create invitations"
  ON invitations FOR INSERT
  WITH CHECK (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() 
      AND role IN ('owner', 'manager')
    )
  );

CREATE POLICY "Managers can delete their org invitations"
  ON invitations FOR DELETE
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() 
      AND role IN ('owner', 'manager')
    )
  );

-- Public can view valid invitations by token (for join page)
CREATE POLICY "Anyone can view invitation by token"
  ON invitations FOR SELECT
  USING (
    expires_at > NOW() 
    AND accepted_at IS NULL
  );

-- First, drop the old constraint
ALTER TABLE invitations 
DROP CONSTRAINT IF EXISTS invitations_role_check;

-- Add the new constraint that includes 'manager'
ALTER TABLE invitations 
ADD CONSTRAINT invitations_role_check 
CHECK (role IN ('tenant', 'worker', 'manager'));

-----



-- Add usage tracking table
CREATE TABLE IF NOT EXISTS organization_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  month DATE NOT NULL,
  requests_created INTEGER DEFAULT 0,
  sms_sent INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(organization_id, month)
);

CREATE INDEX idx_org_usage_org_month ON organization_usage(organization_id, month DESC);

ALTER TABLE organization_usage ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their org usage"
  ON organization_usage FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

-- Auto-increment function
CREATE OR REPLACE FUNCTION increment_usage(
  org_id UUID,
  usage_type TEXT,
  amount INTEGER DEFAULT 1
)
RETURNS VOID AS $$
DECLARE
  current_month DATE := date_trunc('month', NOW())::DATE;
BEGIN
  INSERT INTO organization_usage (organization_id, month, requests_created, sms_sent)
  VALUES (
    org_id, 
    current_month,
    CASE WHEN usage_type = 'requests' THEN amount ELSE 0 END,
    CASE WHEN usage_type = 'sms' THEN amount ELSE 0 END
  )
  ON CONFLICT (organization_id, month)
  DO UPDATE SET
    requests_created = organization_usage.requests_created + 
      CASE WHEN usage_type = 'requests' THEN amount ELSE 0 END,
    sms_sent = organization_usage.sms_sent + 
      CASE WHEN usage_type = 'sms' THEN amount ELSE 0 END,
    updated_at = NOW();
END;
$$ LANGUAGE plpgsql;

-- Auto-increment when request is created
CREATE OR REPLACE FUNCTION auto_increment_requests()
RETURNS TRIGGER AS $$
BEGIN
  PERFORM increment_usage(NEW.organization_id, 'requests', 1);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER auto_count_requests
  AFTER INSERT ON maintenance_requests
  FOR EACH ROW
  EXECUTE FUNCTION auto_increment_requests();


-- RESET PASSWORDS ---

-- Create password_resets table (similar pattern to invitations)
CREATE TABLE IF NOT EXISTS public.password_resets (
  id UUID NOT NULL DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  token TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMPTZ NOT NULL,
  used_at TIMESTAMPTZ NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT password_resets_pkey PRIMARY KEY (id)
);

-- Create indexes for faster lookups
CREATE INDEX IF NOT EXISTS idx_password_resets_token ON public.password_resets USING btree (token);
CREATE INDEX IF NOT EXISTS idx_password_resets_email ON public.password_resets USING btree (email);
CREATE INDEX IF NOT EXISTS idx_password_resets_user_id ON public.password_resets USING btree (user_id);

-- Enable RLS
ALTER TABLE password_resets ENABLE ROW LEVEL SECURITY;

-- Policy: Anyone can read valid reset tokens (for validation)
CREATE POLICY "Anyone can read valid reset tokens"
  ON password_resets FOR SELECT
  USING (
    used_at IS NULL 
    AND expires_at > NOW()
  );

-- Policy: System can insert reset tokens
CREATE POLICY "System can insert reset tokens"
  ON password_resets FOR INSERT
  WITH CHECK (true);

-- Policy: System can update reset tokens
CREATE POLICY "System can update reset tokens"
  ON password_resets FOR UPDATE
  USING (true);

-- Comments
COMMENT ON TABLE password_resets IS 'Stores password reset tokens with expiration';
COMMENT ON COLUMN password_resets.token IS 'Unique token sent in password reset email';
COMMENT ON COLUMN password_resets.used_at IS 'Timestamp when token was used (prevents reuse)';

--- photos ---


-- Allow authenticated users to upload images
CREATE POLICY "Authenticated users can upload images"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'maintenance-images');

-- Allow everyone to view images (since bucket is public)
CREATE POLICY "Public can view images"
ON storage.objects FOR SELECT
TO public
USING (bucket_id = 'maintenance-images');

-- Allow users to delete their own uploaded images
CREATE POLICY "Users can delete their own images"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'maintenance-images' AND auth.uid() = owner);



-- ============================================
-- Activity Logs RLS Policies
-- (Table already exists, just need policies)
-- ============================================

-- Enable RLS on activity_logs table
ALTER TABLE activity_logs ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if any (safe to run)
DROP POLICY IF EXISTS "Managers can view activity logs" ON activity_logs;
DROP POLICY IF EXISTS "Users can insert activity logs" ON activity_logs;

-- Policy 1: Managers and owners can view all logs in their organization
CREATE POLICY "Managers can view activity logs"
  ON activity_logs
  FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id 
      FROM profiles 
      WHERE id = auth.uid() 
      AND role IN ('manager', 'owner')
    )
  );

-- Policy 2: All authenticated users can insert their own activity logs
CREATE POLICY "Users can insert activity logs"
  ON activity_logs
  FOR INSERT
  WITH CHECK (user_id = auth.uid());

-- Grant permissions to authenticated users
GRANT SELECT, INSERT ON activity_logs TO authenticated;

-- ============================================
-- Verification Query (Optional)
-- ============================================

-- Run this to verify your policies are active:
-- SELECT * FROM pg_policies WHERE tablename = 'activity_logs';

-- ============================================
-- Test Query (Optional - Run as manager/owner)
-- ============================================

-- This should return your organization's activity logs:
-- SELECT * FROM activity_logs ORDER BY created_at DESC LIMIT 10;

-- ============================================
-- Notes
-- ============================================

-- Your existing table structure:
-- id (uuid, primary key)
-- organization_id (uuid, references organizations)
-- request_id (uuid, references maintenance_requests)
-- user_id (uuid, references profiles)
-- action (text, required)
-- details (jsonb, optional - stores any additional data)
-- created_at (timestamp with time zone)

-- Indexes already present:
-- idx_activity_org on organization_id
-- idx_activity_request on request_id



-- ============================================
-- Avatar Storage Bucket Setup
-- ============================================

-- Create the avatars bucket (run this in Supabase Dashboard → Storage)
-- Note: This is typically done through the UI, but here's the equivalent SQL

-- 1. Create bucket through Supabase Dashboard UI:
-- Go to Storage → Create a new bucket
-- Name: avatars
-- Public: YES (so avatars can be viewed)
-- File size limit: 5242880 (5MB)
-- Allowed MIME types: image/*

-- ============================================
-- Storage Policies for avatars bucket
-- ============================================

-- Policy 1: Anyone can view avatars (public read)
CREATE POLICY "Public Avatar Access"
ON storage.objects FOR SELECT
USING ( bucket_id = 'avatars' );

-- Policy 2: Users can upload their own avatar
CREATE POLICY "Users can upload own avatar"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'avatars' 
  AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Policy 3: Users can update their own avatar
CREATE POLICY "Users can update own avatar"
ON storage.objects FOR UPDATE
USING (
  bucket_id = 'avatars' 
  AND (storage.foldername(name))[1] = auth.uid()::text
)
WITH CHECK (
  bucket_id = 'avatars' 
  AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Policy 4: Users can delete their own avatar
CREATE POLICY "Users can delete own avatar"
ON storage.objects FOR DELETE
USING (
  bucket_id = 'avatars' 
  AND (storage.foldername(name))[1] = auth.uid()::text
);

-- ============================================
-- Verify avatar_url column exists in profiles
-- ============================================

-- Check if avatar_url column exists
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'profiles' 
AND column_name = 'avatar_url';

-- If it doesn't exist, add it (but you already have it):
-- ALTER TABLE profiles ADD COLUMN avatar_url TEXT;

-- ============================================
-- Index for faster avatar lookups (optional)
-- ============================================

CREATE INDEX IF NOT EXISTS idx_profiles_avatar 
ON profiles(avatar_url) 
WHERE avatar_url IS NOT NULL;

-- ============================================
-- Notes
-- ============================================

/*
Folder Structure in avatars bucket:
avatars/
  └── {user_id}/
      ├── 1234567890.jpg
      ├── 1234567891.png
      └── ...

Each user can only access their own folder.
Avatars are publicly readable.

Usage in JavaScript:
1. Upload: supabase.storage.from('avatars').upload(`${userId}/${filename}`, file)
2. Get URL: supabase.storage.from('avatars').getPublicUrl(`${userId}/${filename}`)
3. Delete: supabase.storage.from('avatars').remove([`${userId}/${filename}`])
*/

-- =====================================================
-- PART 1: SUBSCRIPTION TIERS TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS subscription_tiers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,
  display_name TEXT NOT NULL,
  description TEXT,
  
  -- Pricing
  price_monthly DECIMAL(10,2) NOT NULL DEFAULT 0,
  price_yearly DECIMAL(10,2),
  
  -- Limits
  max_properties INTEGER,
  max_units INTEGER,
  max_tenants INTEGER,
  max_workers INTEGER,
  max_sms_per_month INTEGER DEFAULT 0,
  
  -- Features (JSON array)
  features JSONB DEFAULT '[]'::jsonb,
  
  -- Stripe integration
  stripe_price_id_monthly TEXT,
  stripe_price_id_yearly TEXT,
  
  -- Status
  is_active BOOLEAN DEFAULT true,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- PART 2: UPDATE ORGANIZATIONS TABLE
-- =====================================================

-- Add subscription columns
ALTER TABLE organizations 
ADD COLUMN IF NOT EXISTS subscription_tier_id UUID REFERENCES subscription_tiers(id),
ADD COLUMN IF NOT EXISTS subscription_period_start TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS subscription_period_end TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS subscription_status TEXT DEFAULT 'active';

-- Add Stripe columns
ALTER TABLE organizations 
ADD COLUMN IF NOT EXISTS stripe_customer_id TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS stripe_subscription_id TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS stripe_subscription_status TEXT,
ADD COLUMN IF NOT EXISTS stripe_current_period_end TIMESTAMPTZ;

-- =====================================================
-- PART 3: SUBSCRIPTION HISTORY TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS subscription_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  
  -- Action type: 'upgraded', 'downgraded', 'renewed', 'canceled', etc.
  action TEXT NOT NULL,
  
  -- Tier changes
  previous_tier_id UUID REFERENCES subscription_tiers(id),
  new_tier_id UUID REFERENCES subscription_tiers(id),
  
  -- Payment info
  amount DECIMAL(10,2),
  
  -- Additional data
  metadata JSONB DEFAULT '{}'::jsonb,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES profiles(id)
);

-- =====================================================
-- PART 4: STRIPE EVENTS TABLE (Idempotency)
-- =====================================================

CREATE TABLE IF NOT EXISTS stripe_events (
  id TEXT PRIMARY KEY, -- Stripe event ID
  type TEXT NOT NULL,
  processed BOOLEAN DEFAULT false,
  data JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- PART 5: ORGANIZATION USAGE TRACKING TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS organization_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  
  -- Month tracking (e.g., '2024-01-01')
  month DATE NOT NULL,
  
  -- Usage counters
  sms_sent INTEGER DEFAULT 0,
  api_calls INTEGER DEFAULT 0,
  storage_mb DECIMAL(10,2) DEFAULT 0,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Unique constraint: one record per org per month
  UNIQUE(organization_id, month)
);

-- =====================================================
-- PART 6: INSERT SUBSCRIPTION TIERS
-- =====================================================

INSERT INTO subscription_tiers (
  name, 
  display_name, 
  description, 
  price_monthly, 
  price_yearly, 
  max_properties, 
  max_units, 
  max_tenants, 
  max_workers, 
  max_sms_per_month,
  features
) VALUES
  -- FREE TIER
  (
    'free',
    'Free',
    'Perfect for getting started',
    0.00,
    0.00,
    1,           -- 1 property
    5,           -- 5 units
    5,           -- 5 tenants
    2,           -- 2 workers (manager + 1 maintenance)
    0,           -- No SMS
    '[
      "1 property",
      "5 units",
      "5 tenants",
      "2 workers",
      "Unlimited requests",
      "Email notifications",
      "Mobile access",
      "Basic support"
    ]'::jsonb
  ),
  
  -- STARTER TIER
  (
    'starter',
    'Starter',
    'For small property managers',
    29.00,
    290.00,      -- Save $58/year (2 months free)
    3,           -- 3 properties
    50,          -- 50 units
    50,          -- 50 tenants
    5,           -- 5 workers
    0,           -- No SMS (email only)
    '[
      "3 properties",
      "50 units",
      "50 tenants",
      "5 workers",
      "Unlimited requests",
      "Email notifications",
      "Priority support",
      "Custom branding",
      "Basic analytics"
    ]'::jsonb
  ),
  
  -- PROFESSIONAL TIER (Most Popular)
  (
    'professional',
    'Professional',
    'For growing portfolios',
    79.00,
    790.00,      -- Save $158/year
    10,          -- 10 properties
    200,         -- 200 units
    200,         -- 200 tenants
    15,          -- 15 workers
    2000,        -- 2000 SMS per month
    '[
      "10 properties",
      "200 units",
      "200 tenants",
      "15 workers",
      "Unlimited requests",
      "✨ SMS notifications (2000/month)",
      "Email notifications",
      "Advanced analytics",
      "API access",
      "Phone support",
      "Custom integrations"
    ]'::jsonb
  ),
  
  -- ENTERPRISE TIER
  (
    'enterprise',
    'Enterprise',
    'For large companies',
    199.00,
    1990.00,     -- Save $398/year
    NULL,        -- Unlimited properties
    NULL,        -- Unlimited units
    NULL,        -- Unlimited tenants
    NULL,        -- Unlimited workers
    NULL,        -- Unlimited SMS
    '[
      "Unlimited properties",
      "Unlimited units",
      "Unlimited tenants",
      "Unlimited workers",
      "Unlimited requests",
      "✨ Unlimited SMS",
      "Email notifications",
      "Dedicated account manager",
      "Custom integrations",
      "White label option",
      "SLA guarantee",
      "Priority 24/7 support",
      "Advanced security features"
    ]'::jsonb
  )
ON CONFLICT (name) DO UPDATE SET
  display_name = EXCLUDED.display_name,
  description = EXCLUDED.description,
  price_monthly = EXCLUDED.price_monthly,
  price_yearly = EXCLUDED.price_yearly,
  max_properties = EXCLUDED.max_properties,
  max_units = EXCLUDED.max_units,
  max_tenants = EXCLUDED.max_tenants,
  max_workers = EXCLUDED.max_workers,
  max_sms_per_month = EXCLUDED.max_sms_per_month,
  features = EXCLUDED.features;

-- =====================================================
-- PART 7: MIGRATE EXISTING ORGANIZATIONS TO FREE TIER
-- =====================================================

-- Sync organizations that already have a 'plan' column
UPDATE organizations o
SET subscription_tier_id = st.id
FROM subscription_tiers st
WHERE o.plan = st.name 
  AND o.subscription_tier_id IS NULL;

-- Set all remaining organizations to free tier
UPDATE organizations 
SET subscription_tier_id = (SELECT id FROM subscription_tiers WHERE name = 'free')
WHERE subscription_tier_id IS NULL;

-- =====================================================
-- PART 8: CREATE SUBSCRIPTION CHECK FUNCTION
-- =====================================================

CREATE OR REPLACE FUNCTION check_subscription_limit(
  org_id UUID,
  limit_type TEXT
) RETURNS BOOLEAN AS $$
DECLARE
  current_tier subscription_tiers;
  current_count INTEGER;
  max_limit INTEGER;
  current_month DATE := date_trunc('month', NOW())::DATE;
BEGIN
  -- Get organization's current tier
  SELECT st.* INTO current_tier
  FROM organizations o
  JOIN subscription_tiers st ON o.subscription_tier_id = st.id
  WHERE o.id = org_id;

  IF NOT FOUND THEN 
    RETURN FALSE; 
  END IF;

  -- Check based on limit type
  CASE limit_type
    WHEN 'properties' THEN
      SELECT COUNT(*) INTO current_count 
      FROM properties 
      WHERE organization_id = org_id;
      max_limit := current_tier.max_properties;
      
    WHEN 'units' THEN
      SELECT COUNT(*) INTO current_count 
      FROM units u 
      JOIN properties p ON u.property_id = p.id
      WHERE p.organization_id = org_id;
      max_limit := current_tier.max_units;
      
    WHEN 'tenants' THEN
      SELECT COUNT(*) INTO current_count 
      FROM profiles 
      WHERE organization_id = org_id AND role = 'tenant';
      max_limit := current_tier.max_tenants;
      
    WHEN 'workers' THEN
      SELECT COUNT(*) INTO current_count 
      FROM profiles 
      WHERE organization_id = org_id 
        AND role IN ('maintenance', 'manager');
      max_limit := current_tier.max_workers;
      
    WHEN 'sms' THEN
      max_limit := current_tier.max_sms_per_month;
      
      -- If SMS is disabled (0), return false
      IF max_limit = 0 THEN 
        RETURN FALSE; 
      END IF;
      
      -- If unlimited SMS, return true
      IF max_limit IS NULL THEN 
        RETURN TRUE; 
      END IF;
      
      -- Check current month usage
      SELECT COALESCE(sms_sent, 0) INTO current_count
      FROM organization_usage 
      WHERE organization_id = org_id 
        AND month = current_month;
      
    ELSE 
      RETURN FALSE;
  END CASE;

  -- NULL means unlimited
  IF max_limit IS NULL THEN 
    RETURN TRUE; 
  END IF;

  -- Check if under limit
  RETURN current_count < max_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- PART 9: CREATE TRIGGER FUNCTIONS FOR ENFORCEMENT
-- =====================================================

-- Function to enforce property limit
CREATE OR REPLACE FUNCTION enforce_property_limit()
RETURNS TRIGGER AS $$
BEGIN
  IF NOT check_subscription_limit(NEW.organization_id, 'properties') THEN
    RAISE EXCEPTION 'Property limit reached for your subscription plan. Please upgrade to add more properties.';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to enforce unit limit
CREATE OR REPLACE FUNCTION enforce_unit_limit()
RETURNS TRIGGER AS $$
DECLARE 
  org_id UUID;
BEGIN
  -- Get organization_id from property
  SELECT organization_id INTO org_id 
  FROM properties 
  WHERE id = NEW.property_id;
  
  IF NOT check_subscription_limit(org_id, 'units') THEN
    RAISE EXCEPTION 'Unit limit reached for your subscription plan. Please upgrade to add more units.';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to enforce user limit (tenants/workers)
CREATE OR REPLACE FUNCTION enforce_user_limit()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.role = 'tenant' THEN
    IF NOT check_subscription_limit(NEW.organization_id, 'tenants') THEN
      RAISE EXCEPTION 'Tenant limit reached for your subscription plan. Please upgrade to add more tenants.';
    END IF;
  ELSIF NEW.role IN ('maintenance', 'manager') THEN
    IF NOT check_subscription_limit(NEW.organization_id, 'workers') THEN
      RAISE EXCEPTION 'Worker limit reached for your subscription plan. Please upgrade to add more workers.';
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- PART 10: CREATE TRIGGERS
-- =====================================================

-- Drop existing triggers if they exist
DROP TRIGGER IF EXISTS property_limit_check ON properties;
DROP TRIGGER IF EXISTS unit_limit_check ON units;
DROP TRIGGER IF EXISTS user_limit_check ON profiles;

-- Create triggers
CREATE TRIGGER property_limit_check
  BEFORE INSERT ON properties
  FOR EACH ROW 
  EXECUTE FUNCTION enforce_property_limit();

CREATE TRIGGER unit_limit_check
  BEFORE INSERT ON units
  FOR EACH ROW 
  EXECUTE FUNCTION enforce_unit_limit();

CREATE TRIGGER user_limit_check
  BEFORE INSERT ON profiles
  FOR EACH ROW
  WHEN (NEW.role IN ('tenant', 'maintenance', 'manager'))
  EXECUTE FUNCTION enforce_user_limit();

-- =====================================================
-- PART 11: CREATE INDEXES
-- =====================================================

-- Organizations indexes
CREATE INDEX IF NOT EXISTS idx_organizations_subscription_tier 
  ON organizations(subscription_tier_id);
CREATE INDEX IF NOT EXISTS idx_organizations_stripe_customer 
  ON organizations(stripe_customer_id);
CREATE INDEX IF NOT EXISTS idx_organizations_stripe_subscription 
  ON organizations(stripe_subscription_id);

-- Subscription history indexes
CREATE INDEX IF NOT EXISTS idx_subscription_history_org 
  ON subscription_history(organization_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_subscription_history_action 
  ON subscription_history(action, created_at DESC);

-- Stripe events indexes
CREATE INDEX IF NOT EXISTS idx_stripe_events_processed 
  ON stripe_events(processed, created_at);
CREATE INDEX IF NOT EXISTS idx_stripe_events_type 
  ON stripe_events(type, created_at DESC);

-- Usage tracking indexes
CREATE INDEX IF NOT EXISTS idx_organization_usage_org_month 
  ON organization_usage(organization_id, month);

-- =====================================================
-- PART 12: ROW LEVEL SECURITY (RLS)
-- =====================================================

-- Enable RLS on new tables
ALTER TABLE subscription_tiers ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscription_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE stripe_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_usage ENABLE ROW LEVEL SECURITY;

-- Subscription tiers: Anyone can view active tiers
CREATE POLICY "Anyone can view active subscription tiers"
  ON subscription_tiers 
  FOR SELECT 
  USING (is_active = true);

-- Subscription history: Users can view their org's history
CREATE POLICY "Users can view their organization subscription history"
  ON subscription_history 
  FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id 
      FROM profiles 
      WHERE id = auth.uid()
    )
  );

-- Subscription history: System can insert
CREATE POLICY "System can insert subscription history"
  ON subscription_history 
  FOR INSERT 
  WITH CHECK (true);

-- Stripe events: System only
CREATE POLICY "System can manage stripe events"
  ON stripe_events 
  FOR ALL 
  USING (true);

-- Organization usage: Users can view their org's usage
CREATE POLICY "Users can view their organization usage"
  ON organization_usage 
  FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id 
      FROM profiles 
      WHERE id = auth.uid()
    )
  );

-- Organization usage: System can insert/update
CREATE POLICY "System can manage organization usage"
  ON organization_usage 
  FOR ALL 
  USING (true);

-- =====================================================
-- PART 13: GRANT PERMISSIONS
-- =====================================================

GRANT SELECT ON subscription_tiers TO authenticated, anon;
GRANT SELECT ON subscription_history TO authenticated;
GRANT ALL ON stripe_events TO authenticated;
GRANT SELECT ON organization_usage TO authenticated;

GRANT EXECUTE ON FUNCTION check_subscription_limit TO authenticated;

-- =====================================================
-- PART 14: CREATE HELPER FUNCTIONS
-- =====================================================

-- Function to get organization's current subscription status
CREATE OR REPLACE FUNCTION get_organization_subscription(org_id UUID)
RETURNS TABLE (
  organization_id UUID,
  organization_name TEXT,
  tier_id UUID,
  tier_name TEXT,
  tier_display_name TEXT,
  price_monthly DECIMAL,
  max_properties INTEGER,
  max_units INTEGER,
  max_tenants INTEGER,
  max_workers INTEGER,
  max_sms INTEGER,
  stripe_status TEXT,
  period_end TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    o.id as organization_id,
    o.name as organization_name,
    st.id as tier_id,
    st.name as tier_name,
    st.display_name as tier_display_name,
    st.price_monthly,
    st.max_properties,
    st.max_units,
    st.max_tenants,
    st.max_workers,
    st.max_sms_per_month as max_sms,
    o.stripe_subscription_status as stripe_status,
    o.stripe_current_period_end as period_end
  FROM organizations o
  JOIN subscription_tiers st ON o.subscription_tier_id = st.id
  WHERE o.id = org_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to increment SMS usage
CREATE OR REPLACE FUNCTION increment_sms_usage(
  org_id UUID,
  count INTEGER DEFAULT 1
)
RETURNS BOOLEAN AS $$
DECLARE
  current_month DATE := date_trunc('month', NOW())::DATE;
BEGIN
  -- Insert or update usage
  INSERT INTO organization_usage (organization_id, month, sms_sent)
  VALUES (org_id, current_month, count)
  ON CONFLICT (organization_id, month)
  DO UPDATE SET 
    sms_sent = organization_usage.sms_sent + count,
    updated_at = NOW();
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION get_organization_subscription TO authenticated;
GRANT EXECUTE ON FUNCTION increment_sms_usage TO authenticated;

-- =====================================================
-- PART 15: CREATE VIEWS FOR REPORTING
-- =====================================================

-- View: Active subscriptions
CREATE OR REPLACE VIEW active_subscriptions AS
SELECT 
  o.id as organization_id,
  o.name as organization_name,
  st.display_name as tier,
  st.price_monthly,
  o.stripe_subscription_status,
  o.stripe_current_period_end,
  CASE 
    WHEN o.stripe_current_period_end < NOW() THEN 'Expired'
    WHEN o.stripe_current_period_end < NOW() + INTERVAL '7 days' THEN 'Expiring Soon'
    ELSE 'Active'
  END as status
FROM organizations o
JOIN subscription_tiers st ON o.subscription_tier_id = st.id
WHERE o.stripe_subscription_id IS NOT NULL;

-- View: Revenue metrics
CREATE OR REPLACE VIEW revenue_metrics AS
SELECT 
  st.display_name as tier,
  st.price_monthly,
  COUNT(*) as customer_count,
  COUNT(*) * st.price_monthly as monthly_recurring_revenue
FROM organizations o
JOIN subscription_tiers st ON o.subscription_tier_id = st.id
WHERE o.stripe_subscription_status = 'active'
GROUP BY st.display_name, st.price_monthly
ORDER BY monthly_recurring_revenue DESC;

-- =====================================================
-- VERIFICATION QUERIES
-- =====================================================

-- ✅ Verify subscription tiers created
SELECT 
  display_name, 
  price_monthly, 
  max_properties, 
  max_units,
  max_sms_per_month,
  jsonb_array_length(features) as feature_count
FROM subscription_tiers 
ORDER BY price_monthly;

-- ✅ Verify organizations have tiers
SELECT 
  o.name,
  st.display_name as tier
FROM organizations o
LEFT JOIN subscription_tiers st ON o.subscription_tier_id = st.id
LIMIT 10;

-- ✅ Count organizations by tier
SELECT 
  st.display_name as tier,
  COUNT(*) as organization_count
FROM organizations o
JOIN subscription_tiers st ON o.subscription_tier_id = st.id
GROUP BY st.display_name
ORDER BY COUNT(*) DESC;

-- =====================================================
-- DONE! ✅
-- =====================================================

-- =====================================================
-- IMPORTANT: UPDATE STRIPE PRICE IDs
-- =====================================================

-- After creating products in Stripe, run these queries:
-- (Replace 'price_xxxxx' with your actual Stripe Price IDs)


UPDATE subscription_tiers 
SET stripe_price_id_monthly = 'price_1Sl4F2RCrlBsTPfX5iHHfNJM'
WHERE name = 'starter';

UPDATE subscription_tiers 
SET stripe_price_id_monthly = 'price_1Sl4FeRCrlBsTPfXQPSMT9XP'
WHERE name = 'professional';

UPDATE subscription_tiers 
SET stripe_price_id_monthly = 'price_1Sl4G9RCrlBsTPfXjjXv9EHx'
WHERE name = 'enterprise';

-- Optional: Add yearly prices
UPDATE subscription_tiers 
SET stripe_price_id_yearly = 'price_1Sl4IiRCrlBsTPfXK84RV96f'
WHERE name = 'starter';

UPDATE subscription_tiers 
SET stripe_price_id_yearly = 'price_1Sl4JMRCrlBsTPfX2IfghDCp'
WHERE name = 'professional';

UPDATE subscription_tiers 
SET stripe_price_id_yearly = 'price_1Sl4JsRCrlBsTPfXZWnhxOfA'
WHERE name = 'enterprise';



-- ✅ Create check_subscription_limit function
CREATE OR REPLACE FUNCTION check_subscription_limit(
  org_id uuid,
  limit_type text
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  tier_record RECORD;
  current_count integer;
  max_allowed integer;
BEGIN
  -- Get organization's tier (with fallback to free tier)
  SELECT 
    COALESCE(st.max_properties, ft.max_properties) as max_properties,
    COALESCE(st.max_units, ft.max_units) as max_units,
    COALESCE(st.max_tenants, ft.max_tenants) as max_tenants,
    COALESCE(st.max_workers, ft.max_workers) as max_workers,
    COALESCE(st.max_sms_per_month, ft.max_sms_per_month) as max_sms_per_month
  INTO tier_record
  FROM organizations o
  CROSS JOIN (SELECT * FROM subscription_tiers WHERE name = 'free' LIMIT 1) ft
  LEFT JOIN subscription_tiers st ON st.id = o.subscription_tier_id
  WHERE o.id = org_id;

  -- If organization not found, deny
  IF NOT FOUND THEN
    RAISE LOG 'Organization not found: %', org_id;
    RETURN false;
  END IF;

  -- Get the limit and current count for this resource type
  CASE limit_type
    WHEN 'properties' THEN
      max_allowed := tier_record.max_properties;
      SELECT COUNT(*) INTO current_count 
      FROM properties 
      WHERE organization_id = org_id;
    
    WHEN 'units' THEN
      max_allowed := tier_record.max_units;
      SELECT COUNT(*) INTO current_count 
      FROM units u 
      JOIN properties p ON p.id = u.property_id 
      WHERE p.organization_id = org_id;
    
    WHEN 'tenants' THEN
      max_allowed := tier_record.max_tenants;
      SELECT COUNT(*) INTO current_count 
      FROM profiles 
      WHERE organization_id = org_id AND role = 'tenant';
    
    WHEN 'workers' THEN
      max_allowed := tier_record.max_workers;
      SELECT COUNT(*) INTO current_count 
      FROM profiles 
      WHERE organization_id = org_id AND role IN ('manager', 'maintenance');
    
    WHEN 'sms' THEN
      max_allowed := tier_record.max_sms_per_month;
      -- For SMS, check current month usage
      SELECT COALESCE(sms_sent, 0) INTO current_count
      FROM organization_usage
      WHERE organization_id = org_id 
        AND month = date_trunc('month', CURRENT_DATE);
      
      -- If no usage record exists, count is 0
      IF current_count IS NULL THEN
        current_count := 0;
      END IF;
    
    ELSE
      RAISE LOG 'Invalid limit_type: %', limit_type;
      RETURN false;
  END CASE;

  -- Log for debugging
  RAISE LOG 'Checking % limit for org %: current=%, max=%', limit_type, org_id, current_count, max_allowed;

  -- NULL limit means unlimited (Enterprise tier)
  IF max_allowed IS NULL THEN
    RETURN true;
  END IF;

  -- Check if under limit (< not <=, so if limit is 1 and count is 0, return true)
  RETURN current_count < max_allowed;
END;
$$;

-- ✅ Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION check_subscription_limit(uuid, text) TO authenticated;

-- ✅ Add comment for documentation
COMMENT ON FUNCTION check_subscription_limit IS 'Checks if organization can add more of a resource type based on subscription tier limits';


-- Property images column already exists as 'photo_url' in your schema
-- No migration needed for the column itself

-- Create storage bucket for property images (run this in Supabase Dashboard > Storage)
-- Bucket name: property-images
-- Public: true
-- File size limit: 5MB
-- Allowed MIME types: image/jpeg, image/png, image/gif, image/webp

-- Storage policies for property-images bucket (run in SQL editor)

-- Allow authenticated users to upload images to their organization folder
CREATE POLICY "Users can upload property images to their org folder"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
  bucket_id = 'property-images' AND
  (storage.foldername(name))[1] IN (
    SELECT organization_id::text 
    FROM profiles 
    WHERE id = auth.uid()
  )
);

-- Allow authenticated users to view property images from their organization
CREATE POLICY "Users can view property images from their org"
ON storage.objects FOR SELECT
TO authenticated
USING (
  bucket_id = 'property-images' AND
  (storage.foldername(name))[1] IN (
    SELECT organization_id::text 
    FROM profiles 
    WHERE id = auth.uid()
  )
);

-- Allow authenticated users to delete property images from their organization
CREATE POLICY "Users can delete property images from their org"
ON storage.objects FOR DELETE
TO authenticated
USING (
  bucket_id = 'property-images' AND
  (storage.foldername(name))[1] IN (
    SELECT organization_id::text 
    FROM profiles 
    WHERE id = auth.uid()
  )
);

-- Allow authenticated users to update property images from their organization
CREATE POLICY "Users can update property images from their org"
ON storage.objects FOR UPDATE
TO authenticated
USING (
  bucket_id = 'property-images' AND
  (storage.foldername(name))[1] IN (
    SELECT organization_id::text 
    FROM profiles 
    WHERE id = auth.uid()
  )
);