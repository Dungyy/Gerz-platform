-- =====================================================
-- GERZ SAAS DATABASE SCHEMA
-- Multi-tenant maintenance request platform
-- =====================================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =====================================================
-- 1. ORGANIZATIONS (Each property management company)
-- =====================================================
CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL, -- gerz.com/acme-properties
  logo_url TEXT,
  plan TEXT NOT NULL DEFAULT 'free', -- 'free', 'starter', 'professional', 'enterprise'
  stripe_customer_id TEXT,
  stripe_subscription_id TEXT,
  subscription_status TEXT DEFAULT 'trialing', -- 'trialing', 'active', 'past_due', 'canceled'
  trial_ends_at TIMESTAMPTZ,
  settings JSONB DEFAULT '{}', -- Custom settings per org
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 2. USERS (Profiles - extends auth.users)
-- =====================================================
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  full_name TEXT NOT NULL,
  email TEXT NOT NULL,
  role TEXT NOT NULL, -- 'owner', 'manager', 'maintenance', 'tenant'
  phone TEXT,
  avatar_url TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 3. PROPERTIES
-- =====================================================
CREATE TABLE properties (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  address TEXT NOT NULL,
  city TEXT,
  state TEXT,
  zip_code TEXT,
  country TEXT DEFAULT 'US',
  property_type TEXT, -- 'apartment', 'condo', 'house', 'commercial'
  manager_id UUID REFERENCES profiles(id),
  photo_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 4. UNITS
-- =====================================================
CREATE TABLE units (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  property_id UUID REFERENCES properties(id) ON DELETE CASCADE,
  unit_number TEXT NOT NULL,
  floor INTEGER,
  bedrooms INTEGER,
  bathrooms DECIMAL(3,1),
  square_feet INTEGER,
  tenant_id UUID REFERENCES profiles(id),
  lease_start_date DATE,
  lease_end_date DATE,
  monthly_rent DECIMAL(10,2),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(property_id, unit_number)
);

-- =====================================================
-- 5. MAINTENANCE REQUESTS
-- =====================================================
CREATE TABLE maintenance_requests (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  property_id UUID REFERENCES properties(id) ON DELETE CASCADE,
  unit_id UUID REFERENCES units(id) ON DELETE CASCADE,
  tenant_id UUID REFERENCES profiles(id),
  assigned_to UUID REFERENCES profiles(id),
  
  -- Request details
  title TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL, -- 'plumbing', 'electrical', 'hvac', 'appliance', 'structural', 'pest', 'other'
  priority TEXT NOT NULL DEFAULT 'medium', -- 'low', 'medium', 'high', 'emergency'
  status TEXT NOT NULL DEFAULT 'submitted', -- 'submitted', 'assigned', 'in_progress', 'completed', 'cancelled'
  
  -- Access and scheduling
  entry_allowed BOOLEAN DEFAULT FALSE,
  preferred_date DATE,
  preferred_time TEXT, -- 'morning', 'afternoon', 'evening', 'anytime'
  
  -- Media
  photo_urls TEXT[],
  
  -- Completion
  resolution_notes TEXT,
  completed_at TIMESTAMPTZ,
  completed_by UUID REFERENCES profiles(id),
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 6. REQUEST COMMENTS/UPDATES
-- =====================================================
CREATE TABLE request_comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  request_id UUID REFERENCES maintenance_requests(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id),
  comment TEXT NOT NULL,
  is_internal BOOLEAN DEFAULT FALSE, -- Only managers/staff see this
  photo_urls TEXT[],
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 7. MAINTENANCE STAFF
-- =====================================================
CREATE TABLE maintenance_staff (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  profile_id UUID REFERENCES profiles(id),
  specialties TEXT[], -- ['plumbing', 'electrical', 'hvac']
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- 8. ACTIVITY LOG
-- =====================================================
CREATE TABLE activity_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  request_id UUID REFERENCES maintenance_requests(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id),
  action TEXT NOT NULL, -- 'created', 'updated', 'assigned', 'commented', 'completed'
  details JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================
CREATE INDEX idx_profiles_org ON profiles(organization_id);
CREATE INDEX idx_profiles_role ON profiles(role);
CREATE INDEX idx_properties_org ON properties(organization_id);
CREATE INDEX idx_units_property ON units(property_id);
CREATE INDEX idx_units_tenant ON units(tenant_id);
CREATE INDEX idx_requests_org ON maintenance_requests(organization_id);
CREATE INDEX idx_requests_property ON maintenance_requests(property_id);
CREATE INDEX idx_requests_status ON maintenance_requests(status);
CREATE INDEX idx_requests_tenant ON maintenance_requests(tenant_id);
CREATE INDEX idx_requests_assigned ON maintenance_requests(assigned_to);
CREATE INDEX idx_requests_created ON maintenance_requests(created_at);
CREATE INDEX idx_comments_request ON request_comments(request_id);
CREATE INDEX idx_activity_org ON activity_logs(organization_id);
CREATE INDEX idx_activity_request ON activity_logs(request_id);

-- =====================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE properties ENABLE ROW LEVEL SECURITY;
ALTER TABLE units ENABLE ROW LEVEL SECURITY;
ALTER TABLE maintenance_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE request_comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE maintenance_staff ENABLE ROW LEVEL SECURITY;
ALTER TABLE activity_logs ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- PROFILES POLICIES
-- =====================================================
CREATE POLICY "Users can view profiles in their org"
  ON profiles FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "Users can update their own profile"
  ON profiles FOR UPDATE
  USING (id = auth.uid());

-- =====================================================
-- ORGANIZATIONS POLICIES
-- =====================================================
CREATE POLICY "Users can view their own organization"
  ON organizations FOR SELECT
  USING (
    id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "Organization owners can update their org"
  ON organizations FOR UPDATE
  USING (
    id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role = 'owner'
    )
  );

-- =====================================================
-- PROPERTIES POLICIES
-- =====================================================
CREATE POLICY "Users can view properties in their org"
  ON properties FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "Managers and owners can create properties"
  ON properties FOR INSERT
  WITH CHECK (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role IN ('owner', 'manager')
    )
  );

CREATE POLICY "Managers and owners can update properties"
  ON properties FOR UPDATE
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role IN ('owner', 'manager')
    )
  );

-- =====================================================
-- UNITS POLICIES
-- =====================================================
CREATE POLICY "Users can view units in their org"
  ON units FOR SELECT
  USING (
    property_id IN (
      SELECT id FROM properties 
      WHERE organization_id IN (
        SELECT organization_id FROM profiles WHERE id = auth.uid()
      )
    )
  );

CREATE POLICY "Managers can manage units"
  ON units FOR ALL
  USING (
    property_id IN (
      SELECT id FROM properties 
      WHERE organization_id IN (
        SELECT organization_id FROM profiles 
        WHERE id = auth.uid() AND role IN ('owner', 'manager')
      )
    )
  );

-- =====================================================
-- MAINTENANCE REQUESTS POLICIES
-- =====================================================
CREATE POLICY "Tenants can view their own requests"
  ON maintenance_requests FOR SELECT
  USING (tenant_id = auth.uid());

CREATE POLICY "Staff can view all requests in their org"
  ON maintenance_requests FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role IN ('owner', 'manager', 'maintenance')
    )
  );

CREATE POLICY "Tenants can create requests"
  ON maintenance_requests FOR INSERT
  WITH CHECK (
    tenant_id = auth.uid() AND
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "Staff can update requests in their org"
  ON maintenance_requests FOR UPDATE
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() AND role IN ('owner', 'manager', 'maintenance')
    )
  );

-- =====================================================
-- REQUEST COMMENTS POLICIES
-- =====================================================
CREATE POLICY "Users can view comments on requests they can see"
  ON request_comments FOR SELECT
  USING (
    -- Can see request
    request_id IN (
      SELECT id FROM maintenance_requests 
      WHERE tenant_id = auth.uid()
      OR organization_id IN (
        SELECT organization_id FROM profiles 
        WHERE id = auth.uid() AND role IN ('owner', 'manager', 'maintenance')
      )
    )
    AND
    -- If internal comment, must be staff
    (
      is_internal = FALSE
      OR
      auth.uid() IN (
        SELECT id FROM profiles 
        WHERE role IN ('owner', 'manager', 'maintenance')
      )
    )
  );

CREATE POLICY "Users can create comments on requests they can see"
  ON request_comments FOR INSERT
  WITH CHECK (
    user_id = auth.uid() AND
    request_id IN (
      SELECT id FROM maintenance_requests 
      WHERE tenant_id = auth.uid()
      OR organization_id IN (
        SELECT organization_id FROM profiles WHERE id = auth.uid()
      )
    )
  );

-- =====================================================
-- FUNCTIONS
-- =====================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_organizations_updated_at BEFORE UPDATE ON organizations
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_properties_updated_at BEFORE UPDATE ON properties
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_units_updated_at BEFORE UPDATE ON units
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_requests_updated_at BEFORE UPDATE ON maintenance_requests
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to log activity
CREATE OR REPLACE FUNCTION log_request_activity()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO activity_logs (organization_id, request_id, user_id, action, details)
  VALUES (
    NEW.organization_id,
    NEW.id,
    auth.uid(),
    TG_OP,
    jsonb_build_object(
      'status', NEW.status,
      'assigned_to', NEW.assigned_to
    )
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger for activity logging
CREATE TRIGGER log_request_changes AFTER INSERT OR UPDATE ON maintenance_requests
  FOR EACH ROW EXECUTE FUNCTION log_request_activity();
```
&

-- Add SMS preferences to profiles table
ALTER TABLE profiles 
ADD COLUMN IF NOT EXISTS phone_verified BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS sms_notifications BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS sms_verification_code VARCHAR(6),
ADD COLUMN IF NOT EXISTS sms_verification_expires_at TIMESTAMPTZ;

-- Add SMS logs table for tracking
CREATE TABLE IF NOT EXISTS sms_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  recipient_phone VARCHAR(20) NOT NULL,
  recipient_user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  message_type VARCHAR(50) NOT NULL, -- 'invitation', 'request_update', 'verification', etc.
  message_body TEXT NOT NULL,
  status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'sent', 'delivered', 'failed'
  twilio_sid VARCHAR(100),
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  delivered_at TIMESTAMPTZ
);

-- Add indexes
CREATE INDEX IF NOT EXISTS idx_sms_logs_organization ON sms_logs(organization_id);
CREATE INDEX IF NOT EXISTS idx_sms_logs_recipient ON sms_logs(recipient_user_id);
CREATE INDEX IF NOT EXISTS idx_sms_logs_created ON sms_logs(created_at DESC);

-- Enable RLS
ALTER TABLE sms_logs ENABLE ROW LEVEL SECURITY;

-- RLS Policies for sms_logs
CREATE POLICY "Users can view SMS logs in their org"
  ON sms_logs FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

CREATE POLICY "System can insert SMS logs"
  ON sms_logs FOR INSERT
  WITH CHECK (true);

-- Add notification preferences table
CREATE TABLE IF NOT EXISTS notification_preferences (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE UNIQUE,
  email_new_request BOOLEAN DEFAULT true,
  email_status_update BOOLEAN DEFAULT true,
  email_assignment BOOLEAN DEFAULT true,
  email_comment BOOLEAN DEFAULT true,
  sms_new_request BOOLEAN DEFAULT false,
  sms_status_update BOOLEAN DEFAULT true,
  sms_assignment BOOLEAN DEFAULT false,
  sms_emergency BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE notification_preferences ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own preferences"
  ON notification_preferences FOR SELECT
  USING (user_id = auth.uid());

CREATE POLICY "Users can update own preferences"
  ON notification_preferences FOR UPDATE
  USING (user_id = auth.uid());

CREATE POLICY "Users can insert own preferences"
  ON notification_preferences FOR INSERT
  WITH CHECK (user_id = auth.uid());

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_notification_preferences_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER notification_preferences_updated_at
  BEFORE UPDATE ON notification_preferences
  FOR EACH ROW
  EXECUTE FUNCTION update_notification_preferences_updated_at();


-- =========================================
-- CONTACT MESSAGES
-- =========================================
create table if not exists public.contact_messages (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  email text not null,
  subject text,
  message text not null,
  source text default 'web',
  status text not null default 'new' check (status in ('new','read','closed')),
  created_at timestamptz not null default now()
);

create index if not exists contact_messages_created_at_idx
  on public.contact_messages (created_at desc);

create index if not exists contact_messages_status_idx
  on public.contact_messages (status);

-- Optional: basic email format check (simple)
-- alter table public.contact_messages add constraint contact_messages_email_chk check (position('@' in email) > 1);


-- =========================================
-- FEATURE REQUESTS
-- =========================================
create table if not exists public.feature_requests (
  id uuid primary key default gen_random_uuid(),
  name text,
  email text,
  title text not null,
  details text not null,
  priority text not null default 'medium' check (priority in ('low','medium','high')),
  status text not null default 'new' check (status in ('new','reviewing','planned','shipped','closed')),
  created_at timestamptz not null default now()
);

create index if not exists feature_requests_created_at_idx
  on public.feature_requests (created_at desc);

create index if not exists feature_requests_status_idx
  on public.feature_requests (status);

create index if not exists feature_requests_priority_idx
  on public.feature_requests (priority);


-- request comments ---

-- Add organization_id column to request_comments table
ALTER TABLE request_comments 
ADD COLUMN IF NOT EXISTS organization_id UUID REFERENCES organizations(id);

-- Update existing comments with organization_id from the related request
UPDATE request_comments 
SET organization_id = (
  SELECT organization_id 
  FROM maintenance_requests 
  WHERE maintenance_requests.id = request_comments.request_id
)
WHERE organization_id IS NULL;

-- Make it NOT NULL after backfilling
ALTER TABLE request_comments 
ALTER COLUMN organization_id SET NOT NULL;

-- Add index for performance
CREATE INDEX IF NOT EXISTS idx_request_comments_organization_id 
ON request_comments(organization_id);

-- Verify the schema
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'request_comments';



-- Create invitations table
CREATE TABLE IF NOT EXISTS invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  invited_by UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('tenant', 'worker')),
  token TEXT NOT NULL UNIQUE,
  property_id UUID REFERENCES properties(id) ON DELETE SET NULL,
  unit_id UUID REFERENCES units(id) ON DELETE SET NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  accepted_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT valid_role CHECK (role IN ('tenant', 'worker'))
);

-- Index for faster lookups
CREATE INDEX idx_invitations_token ON invitations(token);
CREATE INDEX idx_invitations_email ON invitations(email);
CREATE INDEX idx_invitations_organization ON invitations(organization_id);

-- Enable RLS
ALTER TABLE invitations ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Managers can view their org invitations"
  ON invitations FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() 
      AND role IN ('owner', 'manager')
    )
  );

CREATE POLICY "Managers can create invitations"
  ON invitations FOR INSERT
  WITH CHECK (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() 
      AND role IN ('owner', 'manager')
    )
  );

CREATE POLICY "Managers can delete their org invitations"
  ON invitations FOR DELETE
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles 
      WHERE id = auth.uid() 
      AND role IN ('owner', 'manager')
    )
  );

-- Public can view valid invitations by token (for join page)
CREATE POLICY "Anyone can view invitation by token"
  ON invitations FOR SELECT
  USING (
    expires_at > NOW() 
    AND accepted_at IS NULL
  );

-- First, drop the old constraint
ALTER TABLE invitations 
DROP CONSTRAINT IF EXISTS invitations_role_check;

-- Add the new constraint that includes 'manager'
ALTER TABLE invitations 
ADD CONSTRAINT invitations_role_check 
CHECK (role IN ('tenant', 'worker', 'manager'));

-----



-- Add usage tracking table
CREATE TABLE IF NOT EXISTS organization_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  month DATE NOT NULL,
  requests_created INTEGER DEFAULT 0,
  sms_sent INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(organization_id, month)
);

CREATE INDEX idx_org_usage_org_month ON organization_usage(organization_id, month DESC);

ALTER TABLE organization_usage ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their org usage"
  ON organization_usage FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
  );

-- Auto-increment function
CREATE OR REPLACE FUNCTION increment_usage(
  org_id UUID,
  usage_type TEXT,
  amount INTEGER DEFAULT 1
)
RETURNS VOID AS $$
DECLARE
  current_month DATE := date_trunc('month', NOW())::DATE;
BEGIN
  INSERT INTO organization_usage (organization_id, month, requests_created, sms_sent)
  VALUES (
    org_id, 
    current_month,
    CASE WHEN usage_type = 'requests' THEN amount ELSE 0 END,
    CASE WHEN usage_type = 'sms' THEN amount ELSE 0 END
  )
  ON CONFLICT (organization_id, month)
  DO UPDATE SET
    requests_created = organization_usage.requests_created + 
      CASE WHEN usage_type = 'requests' THEN amount ELSE 0 END,
    sms_sent = organization_usage.sms_sent + 
      CASE WHEN usage_type = 'sms' THEN amount ELSE 0 END,
    updated_at = NOW();
END;
$$ LANGUAGE plpgsql;

-- Auto-increment when request is created
CREATE OR REPLACE FUNCTION auto_increment_requests()
RETURNS TRIGGER AS $$
BEGIN
  PERFORM increment_usage(NEW.organization_id, 'requests', 1);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER auto_count_requests
  AFTER INSERT ON maintenance_requests
  FOR EACH ROW
  EXECUTE FUNCTION auto_increment_requests();


-- RESET PASSWORDS ---

-- Create password_resets table (similar pattern to invitations)
CREATE TABLE IF NOT EXISTS public.password_resets (
  id UUID NOT NULL DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  token TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMPTZ NOT NULL,
  used_at TIMESTAMPTZ NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT password_resets_pkey PRIMARY KEY (id)
);

-- Create indexes for faster lookups
CREATE INDEX IF NOT EXISTS idx_password_resets_token ON public.password_resets USING btree (token);
CREATE INDEX IF NOT EXISTS idx_password_resets_email ON public.password_resets USING btree (email);
CREATE INDEX IF NOT EXISTS idx_password_resets_user_id ON public.password_resets USING btree (user_id);

-- Enable RLS
ALTER TABLE password_resets ENABLE ROW LEVEL SECURITY;

-- Policy: Anyone can read valid reset tokens (for validation)
CREATE POLICY "Anyone can read valid reset tokens"
  ON password_resets FOR SELECT
  USING (
    used_at IS NULL 
    AND expires_at > NOW()
  );

-- Policy: System can insert reset tokens
CREATE POLICY "System can insert reset tokens"
  ON password_resets FOR INSERT
  WITH CHECK (true);

-- Policy: System can update reset tokens
CREATE POLICY "System can update reset tokens"
  ON password_resets FOR UPDATE
  USING (true);

-- Comments
COMMENT ON TABLE password_resets IS 'Stores password reset tokens with expiration';
COMMENT ON COLUMN password_resets.token IS 'Unique token sent in password reset email';
COMMENT ON COLUMN password_resets.used_at IS 'Timestamp when token was used (prevents reuse)';

--- photos ---


-- Allow authenticated users to upload images
CREATE POLICY "Authenticated users can upload images"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'maintenance-images');

-- Allow everyone to view images (since bucket is public)
CREATE POLICY "Public can view images"
ON storage.objects FOR SELECT
TO public
USING (bucket_id = 'maintenance-images');

-- Allow users to delete their own uploaded images
CREATE POLICY "Users can delete their own images"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'maintenance-images' AND auth.uid() = owner);